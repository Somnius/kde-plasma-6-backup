#!/bin/bash

###############################################################################
# KDE Plasma 6 Backup/Restore Wrapper Script
# 
# This is the main entry point for all backup/restore operations.
# It delegates to the appropriate internal scripts.
#
# Usage:
#   ./kde-backup backup [OPTIONS]
#   ./kde-backup restore BACKUP_DIR [OPTIONS]
#   ./kde-backup validate BACKUP_DIR
#   ./kde-backup restore BACKUP_DIR --interactive  # Interactive TUI for selective restore
###############################################################################

set -euo pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check if running latest version from git
check_version() {
    # Only check if we're in a git repository
    if [[ ! -d "${SCRIPT_DIR}/.git" ]]; then
        return 0
    fi
    
    # Get current branch
    local current_branch=$(git -C "${SCRIPT_DIR}" branch --show-current 2>/dev/null || echo "")
    if [[ -z "$current_branch" ]]; then
        return 0
    fi
    
    # Check if remote exists
    local remote=$(git -C "${SCRIPT_DIR}" remote get-url origin 2>/dev/null || echo "")
    if [[ -z "$remote" ]]; then
        return 0
    fi
    
    # Fetch latest (non-blocking, in background)
    git -C "${SCRIPT_DIR}" fetch origin "$current_branch" >/dev/null 2>&1 &
    
    # Check if local is behind remote
    local local_commit=$(git -C "${SCRIPT_DIR}" rev-parse HEAD 2>/dev/null || echo "")
    local remote_commit=$(git -C "${SCRIPT_DIR}" rev-parse "origin/${current_branch}" 2>/dev/null || echo "")
    
    if [[ -z "$local_commit" ]] || [[ -z "$remote_commit" ]]; then
        return 0
    fi
    
    if [[ "$local_commit" != "$remote_commit" ]]; then
        # Check if local is behind
        if git -C "${SCRIPT_DIR}" merge-base --is-ancestor "$local_commit" "$remote_commit" 2>/dev/null; then
            echo ""
            echo -e "${YELLOW}⚠ A newer version is available on ${current_branch} branch${NC}"
            echo -e "${YELLOW}  Current: $(git -C "${SCRIPT_DIR}" log -1 --oneline 2>/dev/null | cut -d' ' -f1)${NC}"
            echo -e "${YELLOW}  Latest:  $(git -C "${SCRIPT_DIR}" log -1 --oneline "origin/${current_branch}" 2>/dev/null | cut -d' ' -f1)${NC}"
            echo ""
            read -p "Update to latest version now? (y/n): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${BLUE}Updating...${NC}"
                if git -C "${SCRIPT_DIR}" pull origin "$current_branch" >/dev/null 2>&1; then
                    echo -e "${GREEN}✓ Updated successfully${NC}"
                    echo -e "${YELLOW}Re-running command with latest version...${NC}"
                    echo ""
                    # Re-execute the script with same arguments
                    exec "$0" "$@"
                else
                    echo -e "${RED}✗ Update failed. Continuing with current version.${NC}"
                    echo ""
                fi
            else
                echo -e "${YELLOW}Continuing with current version...${NC}"
                echo ""
            fi
        fi
    fi
}

# Manually update from git
update_from_git() {
    # Check if we're in a git repository
    if [[ ! -d "${SCRIPT_DIR}/.git" ]]; then
        echo -e "${RED}Error: Not in a git repository${NC}" >&2
        echo "This script must be in a git repository to update." >&2
        exit 1
    fi
    
    # Get current branch
    current_branch=$(git -C "${SCRIPT_DIR}" branch --show-current 2>/dev/null || echo "")
    if [[ -z "$current_branch" ]]; then
        echo -e "${RED}Error: Could not determine current branch${NC}" >&2
        exit 1
    fi
    
    # Check if remote exists
    remote=$(git -C "${SCRIPT_DIR}" remote get-url origin 2>/dev/null || echo "")
    if [[ -z "$remote" ]]; then
        echo -e "${RED}Error: No remote repository configured${NC}" >&2
        echo "Configure a remote with: git remote add origin <url>" >&2
        exit 1
    fi
    
    echo -e "${BLUE}Fetching latest changes from ${remote}...${NC}"
    
    # Fetch latest
    if ! git -C "${SCRIPT_DIR}" fetch origin "$current_branch" 2>&1; then
        echo -e "${RED}Error: Failed to fetch from remote${NC}" >&2
        exit 1
    fi
    
    # Check if there are updates
    local_commit=$(git -C "${SCRIPT_DIR}" rev-parse HEAD 2>/dev/null || echo "")
    remote_commit=$(git -C "${SCRIPT_DIR}" rev-parse "origin/${current_branch}" 2>/dev/null || echo "")
    
    if [[ -z "$local_commit" ]] || [[ -z "$remote_commit" ]]; then
        echo -e "${YELLOW}Warning: Could not compare commits${NC}" >&2
        exit 1
    fi
    
    if [[ "$local_commit" == "$remote_commit" ]]; then
        echo -e "${GREEN}✓ Already up to date${NC}"
        echo -e "${BLUE}Current version: $(git -C "${SCRIPT_DIR}" log -1 --oneline 2>/dev/null)${NC}"
        exit 0
    fi
    
    # Check if local is behind
    if git -C "${SCRIPT_DIR}" merge-base --is-ancestor "$local_commit" "$remote_commit" 2>/dev/null; then
        echo -e "${YELLOW}Local is behind remote${NC}"
        echo -e "${BLUE}Current: $(git -C "${SCRIPT_DIR}" log -1 --oneline 2>/dev/null | cut -d' ' -f1)${NC}"
        echo -e "${BLUE}Latest:  $(git -C "${SCRIPT_DIR}" log -1 --oneline "origin/${current_branch}" 2>/dev/null | cut -d' ' -f1)${NC}"
        echo ""
        read -p "Pull latest changes? (y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${BLUE}Pulling latest changes...${NC}"
            if git -C "${SCRIPT_DIR}" pull origin "$current_branch" 2>&1; then
                echo -e "${GREEN}✓ Updated successfully${NC}"
                echo -e "${BLUE}New version: $(git -C "${SCRIPT_DIR}" log -1 --oneline 2>/dev/null)${NC}"
                exit 0
            else
                echo -e "${RED}✗ Update failed${NC}" >&2
                exit 1
            fi
        else
            echo "Update cancelled."
            exit 0
        fi
    else
        echo -e "${YELLOW}Warning: Local branch has diverged from remote${NC}"
        echo -e "${YELLOW}Current: $(git -C "${SCRIPT_DIR}" log -1 --oneline 2>/dev/null | cut -d' ' -f1)${NC}"
        echo -e "${YELLOW}Remote:  $(git -C "${SCRIPT_DIR}" log -1 --oneline "origin/${current_branch}" 2>/dev/null | cut -d' ' -f1)${NC}"
        echo ""
        echo "You may need to merge or rebase manually."
        exit 1
    fi
}

# Show usage
show_usage() {
    echo "KDE Plasma 6 Backup and Restore Tool"
    echo ""
    echo "Usage:"
    echo "  $0 backup [OPTIONS]"
    echo "  $0 restore BACKUP_DIR [OPTIONS]"
    echo "  $0 validate BACKUP_DIR"
    echo "  $0 update"
    echo ""
    echo "Commands:"
    echo "  backup    - Create a backup of KDE Plasma 6 settings"
    echo "  restore   - Restore KDE Plasma 6 settings from a backup"
    echo "  validate  - Validate a backup's integrity and compatibility"
    echo "  update    - Manually fetch and update to latest version from git"
    echo ""
    echo "For detailed help on each command:"
    echo "  $0 backup --help"
    echo "  $0 restore --help"
    echo "  $0 validate --help"
    echo ""
    echo "Examples:"
    echo "  $0 backup"
    echo "  $0 validate backup-20250104-120000"
    echo "  $0 restore backup-20250104-120000 --skip-display-config"
    echo "  $0 update"
}

# Check if command is provided
if [[ $# -eq 0 ]]; then
    show_usage
    exit 1
fi

# Check for version updates (skip for help command)
COMMAND="$1"
if [[ "$COMMAND" != "help" ]] && [[ "$COMMAND" != "--help" ]] && [[ "$COMMAND" != "-h" ]]; then
    check_version "$@"
fi

shift

# Route to appropriate script
case "$COMMAND" in
    backup)
        exec "${SCRIPT_DIR}/kb-backup.sh" "$@"
        ;;
    restore)
        exec "${SCRIPT_DIR}/kb-restore.sh" "$@"
        ;;
    validate)
        exec "${SCRIPT_DIR}/kb-validate.sh" "$@"
        ;;
    update)
        update_from_git
        ;;
    help|--help|-h)
        show_usage
        exit 0
        ;;
    *)
        echo -e "${RED}Error: Unknown command '${COMMAND}'${NC}" >&2
        echo ""
        show_usage
        exit 1
        ;;
esac

